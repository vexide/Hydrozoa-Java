/*
 * This source file was generated by the Gradle 'init' task
 */
package dev.vexide.hydrozoa.plugin.bindings

import com.github.javaparser.StaticJavaParser
import com.github.javaparser.ast.CompilationUnit
import com.github.javaparser.ast.Modifier
import com.github.javaparser.ast.Modifier.Keyword
import com.github.javaparser.ast.Node
import com.github.javaparser.ast.NodeList
import com.github.javaparser.ast.type.Type
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration
import com.github.javaparser.ast.body.MethodDeclaration
import com.github.javaparser.ast.expr.Expression
import com.github.javaparser.ast.expr.MethodCallExpr
import com.github.javaparser.ast.expr.NameExpr
import com.github.javaparser.ast.expr.StringLiteralExpr
import com.github.javaparser.ast.expr.TypeExpr
import com.github.javaparser.ast.stmt.ExpressionStmt
import com.github.javaparser.ast.stmt.ReturnStmt
import com.github.javaparser.ast.type.PrimitiveType
import com.github.javaparser.ast.type.PrimitiveType.Primitive
import com.github.javaparser.ast.type.VoidType
import com.github.javaparser.utils.SourceRoot
import com.google.common.base.CaseFormat
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.nio.file.Path
import kotlin.jvm.optionals.getOrNull

/**
 * A simple 'hello world' plugin.
 */
class BindingsGeneratorPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Register a task
        project.tasks.register("generateBindings", GenerateBindingsTask::class.java) { task ->
            task.group = "build"
            task.description = "Generates bindings for the Hydrozoa SDK"
            task.doFirst {
                println("Hello from plugin 'org.example.greeting'")
            }
        }
    }
}

@Serializable
data class SdkModule(
    val name: String,
    val items: List<SdkItem>,
    val enums: List<SdkEnum>,
)

@Serializable
data class SdkItem(
    val name: String,
    val params: List<Param>,
    val returns: Type?,
) {
    @Serializable
    data class Param(
        val name: String,
        val type: Type,
    )

    @Serializable
    sealed class Type {
        @Serializable
        @SerialName("Bool")
        object Bool : Type()

        @Serializable
        @SerialName("Int")
        object Int : Type()

        @Serializable
        @SerialName("Long")
        object Long : Type()

        @Serializable
        @SerialName("Float")
        object Float : Type()

        @Serializable
        @SerialName("Double")
        object Double : Type()

        @Serializable
        @SerialName("StringPtr")
        object StringPtr : Type()

        @Serializable
        @SerialName("Named")
        data class Named(val name: String) : Type()
    }
}

@Serializable
data class SdkEnum(
    val name: String,
    @SerialName("underlying_type")
    val underlyingType: SdkItem.Type,
    val variants: Map<String, Double>,
)

abstract class GenerateBindingsTask : DefaultTask() {
    @get:InputFile
    abstract val apiFile: RegularFileProperty

    @get:OutputDirectory
    abstract val outputDirectory: DirectoryProperty

    @TaskAction
    fun generateBindings() {
        val apiFile = apiFile.asFile.get()
        val api = Json.decodeFromString<SdkModule>(apiFile.readText())

        var outDir = outputDirectory.asFile.get().toPath()
        print("Out dir: $outDir")

        var sourceRoot = SourceRoot(outDir)
        sourceRoot.add(JavaSdkModule(api).generate(outDir))
        sourceRoot.saveAll()
    }
}

fun ClassOrInterfaceDeclaration.addStaticInitAnnotation(): ClassOrInterfaceDeclaration {
    return this.addMarkerAnnotation("org.teavm.interop.StaticInit")
}

fun ClassOrInterfaceDeclaration.addPrivateConstructor(): ClassOrInterfaceDeclaration {
    this.addConstructor(Keyword.PRIVATE)
    return this
}

fun<T: Node> nodeListOf(vararg items: T): NodeList<T> {
    return NodeList.nodeList(*items)
}

class JavaSdkModule(val sdk: SdkModule) {
    var enums: Map<String, SdkEnum> = sdk.enums.associateBy { it.name }

    fun generate(sourcesDir: Path): CompilationUnit {
        val className = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, sdk.name) + "Sdk"

        var filename = sourcesDir
        val packageName = "dev.vexide.hydrozoa.sdk.generated"
        for (component in packageName.split(".")) {
            filename = filename.resolve(component)
        }

        val cu = CompilationUnit(packageName)
            .setStorage(filename.resolve("$className.java"))
        print("Filename: ${cu.storage.getOrNull()?.path}")

        cu.setLineComment(" This file was automatically @generated by the Hydrozoa bindings generator. Do not edit this manually!")

        val bindingsClass = cu.addClass(className, Keyword.PUBLIC, Keyword.FINAL)
            .addSingleMemberAnnotation(
                javax.annotation.processing.Generated::class.java,
                StringLiteralExpr("dev.vexide.hydrozoa.plugin.bindings.BindingsGeneratorPlugin")
            )
            .addStaticInitAnnotation()
            .addPrivateConstructor()

        var submodules = mutableMapOf<String, JavaSdkSubmodule>()

        for (item in sdk.items) {
            var (submoduleName, trimmedMethodName) = JavaSdkItem.generateMethodName(item, sdk)

            var submodule = submodules.getOrPut(submoduleName) {
                JavaSdkSubmodule(submoduleName)
            }
            submodule.items.add(JavaSdkItem(item, module = this, methodName = trimmedMethodName))
        }

        for (submodule in submodules.values) {
            submodule.generate(bindingsClass)
        }

        return cu
    }

    fun hasRawType(type: SdkItem.Type): Boolean {
        return when (type) {
//            is SdkItem.Type.Named -> enums[type.name]?.underlyingType != null
            is SdkItem.Type.Named -> true
            else -> false
        }
    }
}

class JavaSdkSubmodule(var submoduleName: String) {
    var items = mutableListOf<JavaSdkItem>()

    fun generate(parentClass: ClassOrInterfaceDeclaration) {
        var submoduleClass = ClassOrInterfaceDeclaration(
            Modifier.createModifierList(Keyword.PUBLIC, Keyword.STATIC, Keyword.FINAL),
            false,
            submoduleName
        )
            .addStaticInitAnnotation()
            .addPrivateConstructor()

        parentClass.addMember(submoduleClass)

        for (item in items) {
            item.generate(submoduleClass)
        }
    }
}

class JavaSdkItem(val sdk: SdkItem, val module: JavaSdkModule, val methodName: String = sdk.name) {
    fun generate(bindingsClass: ClassOrInterfaceDeclaration) {
        val rawMethod = bindingsClass
            .addMethod(sdk.name + "_raw", Keyword.PRIVATE, Keyword.STATIC, Keyword.NATIVE)
            .setType(javaTypeFor(sdk.returns, useRawTypes = true, annotations = true))
            .removeBody()

        rawMethod.addAndGetAnnotation("org.teavm.interop.Import")
            .addPair("module", StringLiteralExpr(module.sdk.name))
            .addPair("name", StringLiteralExpr(sdk.name))

        generateParams(sdk.params, rawMethod, true)

        var method = bindingsClass
            .addMethod(methodName, Keyword.PUBLIC, Keyword.STATIC)
            .setType(javaTypeFor(sdk.returns, annotations = true))

        generateParams(sdk.params, method)
        generateBody(method, rawMethod)
    }

    private fun generateParams(
        params: Iterable<SdkItem.Param>,
        method: MethodDeclaration,
        useUnderlyingTypes: Boolean = false
    ) {
        for (param in params) {
            var paramType = javaTypeFor(param.type, useUnderlyingTypes)
            var methodParam = method.addAndGetParameter(paramType, param.name)
        }
    }

    private fun generateBody(method: MethodDeclaration, rawMethod: MethodDeclaration) {
        var body = method.createBody()

        val nativeMethodCall = MethodCallExpr(null, rawMethod.name)
        for (param in sdk.params) {
            var arg: Expression = NameExpr(param.name)

            if (module.hasRawType(param.type)) {
                arg = MethodCallExpr(arg, "getRawValue")
            }

            nativeMethodCall.addArgument(arg)
        }

        var expr: Expression = nativeMethodCall

        if (sdk.returns != null && module.hasRawType(sdk.returns)) {
            var wrapper = TypeExpr(javaTypeFor(sdk.returns))
            expr = MethodCallExpr(wrapper, "fromRawValue", nodeListOf(nativeMethodCall))
        }

        body.addStatement(
            if (method.type.isVoidType) {
                ExpressionStmt(expr)
            } else {
                ReturnStmt(expr)
            }
        )
    }

    private fun javaTypeFor(type: SdkItem.Type?, useRawTypes: Boolean = false, annotations: Boolean = false): Type {
        return when (type) {
            null -> VoidType()
            is SdkItem.Type.Bool -> PrimitiveType(Primitive.BOOLEAN)
            is SdkItem.Type.Int -> PrimitiveType(Primitive.INT)
            is SdkItem.Type.Long -> PrimitiveType(Primitive.LONG)
            is SdkItem.Type.Float -> PrimitiveType(Primitive.FLOAT)
            is SdkItem.Type.Double -> PrimitiveType(Primitive.DOUBLE)
            is SdkItem.Type.StringPtr -> StaticJavaParser.parseClassOrInterfaceType("String")
                .apply {
                    if (annotations) {
                        addMarkerAnnotation("org.jetbrains.annotations.NotNull")
                    }
                }
            is SdkItem.Type.Named -> {
                if (useRawTypes) {
//                    var underlyingType = module.enums[type.name]?.underlyingType
                    var underlyingType = SdkItem.Type.Int
                    if (underlyingType != null) return javaTypeFor(underlyingType)
                }

                StaticJavaParser
                    .parseClassOrInterfaceType(type.name)
                    .apply {
                        if (annotations) {
                            addMarkerAnnotation("org.jetbrains.annotations.NotNull")
                        }
                    }
            }
        }
    }

    companion object {
        private var actionVerbs =
            setOf("get", "set", "request", "update", "reset", "fill", "draw", "clear", "disable", "enable")

        fun generateMethodName(item: SdkItem, module: SdkModule): Pair<String, String> {
            var nameComponents = ArrayDeque(
                CaseFormat.LOWER_CAMEL
                    .to(CaseFormat.LOWER_UNDERSCORE, item.name)
                    .removePrefix(module.name + "_")
                    .split('_')
            )

            var moduleName = nameComponents.removeFirst()

            // Move verbs to front of method name
            var lastComponent = nameComponents.lastOrNull()
            if (actionVerbs.contains(lastComponent)) {
                nameComponents.add(0, nameComponents.removeLast())
            }

            var submoduleName = CaseFormat.LOWER_UNDERSCORE
                .to(CaseFormat.UPPER_CAMEL, moduleName)
            var trimmedMethodName = CaseFormat.LOWER_UNDERSCORE
                .to(CaseFormat.LOWER_CAMEL, nameComponents.joinToString("_"))

            return Pair(submoduleName, trimmedMethodName)
        }
    }
}
