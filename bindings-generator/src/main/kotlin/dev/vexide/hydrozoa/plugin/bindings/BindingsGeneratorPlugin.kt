/*
 * This source file was generated by the Gradle 'init' task
 */
package dev.vexide.hydrozoa.plugin.bindings

import com.github.javaparser.StaticJavaParser
import com.github.javaparser.ast.CompilationUnit
import com.github.javaparser.ast.Modifier
import com.github.javaparser.ast.Modifier.Keyword
import com.github.javaparser.ast.Node
import com.github.javaparser.ast.NodeList
import com.github.javaparser.ast.type.Type
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration
import com.github.javaparser.ast.body.MethodDeclaration
import com.github.javaparser.ast.body.RecordDeclaration
import com.github.javaparser.ast.expr.CastExpr
import com.github.javaparser.ast.expr.DoubleLiteralExpr
import com.github.javaparser.ast.expr.Expression
import com.github.javaparser.ast.expr.IntegerLiteralExpr
import com.github.javaparser.ast.expr.MethodCallExpr
import com.github.javaparser.ast.expr.NameExpr
import com.github.javaparser.ast.expr.ObjectCreationExpr
import com.github.javaparser.ast.expr.StringLiteralExpr
import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations
import com.github.javaparser.ast.stmt.BlockStmt
import com.github.javaparser.ast.stmt.ExpressionStmt
import com.github.javaparser.ast.stmt.ReturnStmt
import com.github.javaparser.ast.type.ClassOrInterfaceType
import com.github.javaparser.ast.type.PrimitiveType
import com.github.javaparser.ast.type.PrimitiveType.Primitive
import com.github.javaparser.ast.type.VoidType
import com.github.javaparser.utils.SourceRoot
import com.google.common.base.CaseFormat
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import kotlin.io.path.ExperimentalPathApi
import kotlin.io.path.createDirectory
import kotlin.io.path.deleteRecursively
import kotlin.jvm.optionals.getOrNull

/**
 * A simple 'hello world' plugin.
 */
class BindingsGeneratorPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Register a task
        project.tasks.register("generateBindings", GenerateBindingsTask::class.java) { task ->
            task.group = "build"
            task.description = "Generates bindings for the Hydrozoa SDK"
            task.doFirst {
                println("Hello from plugin 'org.example.greeting'")
            }
        }
    }
}

@Serializable
data class SdkModule(
    val name: String,
    val items: List<SdkItem>,
    val enums: List<SdkEnum>,
)

@Serializable
data class SdkItem(
    val name: String,
    val params: List<Param>,
    val returns: Type?,
) {
    @Serializable
    data class Param(
        val name: String,
        val type: Type,
    )

    @Serializable
    sealed class Type {
        @Serializable
        @SerialName("Bool")
        object Bool : Type()

        @Serializable
        @SerialName("Int")
        object Int : Type()

        @Serializable
        @SerialName("Long")
        object Long : Type()

        @Serializable
        @SerialName("Float")
        object Float : Type()

        @Serializable
        @SerialName("Double")
        object Double : Type()

        @Serializable
        @SerialName("StringPtr")
        object StringPtr : Type()

        @Serializable
        @SerialName("Named")
        data class Named(val name: String) : Type()
    }
}

@Serializable
data class SdkEnum(
    val name: String,
    @SerialName("underlying_type")
    val underlyingType: SdkItem.Type,
    val variants: Map<String, Double>,
)

abstract class GenerateBindingsTask : DefaultTask() {
    @get:InputFile
    abstract val apiFile: RegularFileProperty

    @get:OutputDirectory
    abstract val outputDirectory: DirectoryProperty

    @OptIn(ExperimentalPathApi::class)
    @TaskAction
    fun generateBindings() {
        val apiFile = apiFile.asFile.get()
        val api = Json.decodeFromString<SdkModule>(apiFile.readText())

        var outDir = outputDirectory.asFile.get().toPath()
        print("Out dir: $outDir")

        outDir.deleteRecursively()
        outDir.createDirectory()

        var sourceRoot = SourceRoot(outDir)
        JavaSdkModule(api).generate(sourceRoot)
        sourceRoot.saveAll()
    }
}

fun CompilationUnit.addHydrozoaGeneratedComment(): CompilationUnit {
    this.setBlockComment(" This file was automatically @generated by the Hydrozoa bindings generator. Do not edit this manually!\n"
            + "   Instead, update the Hydrozoa SDK at <https://github.com/vexide/hydrozoa> and re-run the generator. ")
    return this
}

fun<N: Node> NodeWithAnnotations<N>.addHydrozoaGeneratedAnnotation(): N {
    return this.addSingleMemberAnnotation(
        javax.annotation.processing.Generated::class.java,
        StringLiteralExpr("dev.vexide.hydrozoa.plugin.bindings.BindingsGeneratorPlugin")
    )
}

fun ClassOrInterfaceDeclaration.addStaticInitAnnotation(): ClassOrInterfaceDeclaration {
    return this.addMarkerAnnotation("org.teavm.interop.StaticInit")
}

fun ClassOrInterfaceDeclaration.addPrivateConstructor(): ClassOrInterfaceDeclaration {
    this.addConstructor(Keyword.PRIVATE)
    return this
}

fun<T: Node> nodeListOf(vararg items: T): NodeList<T> {
    return NodeList.nodeList(*items)
}

fun modifierListOf(vararg modifiers: Keyword): NodeList<Modifier> {
    return Modifier.createModifierList(*modifiers)
}

const val PACKAGE_NAME = "dev.vexide.hydrozoa.sdk"
fun makeCompilationUnit(className: String, sourceRoot: SourceRoot): CompilationUnit {
    var filename = sourceRoot.root
    for (component in PACKAGE_NAME.split(".")) {
        filename = filename.resolve(component)
    }

    val cu = CompilationUnit(PACKAGE_NAME)
        .setStorage(filename.resolve("$className.java"))
    print("Filename: ${cu.storage.getOrNull()?.path}")

    sourceRoot.add(cu)

    return cu
}

class JavaSdkModule(val sdk: SdkModule) {
    var enums: Map<String, SdkEnum> = sdk.enums.associateBy { it.name }

    fun generate(sourceRoot: SourceRoot): CompilationUnit {
        val className = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, sdk.name) + "Sdk"

        val cu = makeCompilationUnit(className, sourceRoot)
            .addHydrozoaGeneratedComment()

        val bindingsClass = cu.addClass(className, Keyword.PUBLIC, Keyword.FINAL)
            .addHydrozoaGeneratedAnnotation()
            .addStaticInitAnnotation()
            .addPrivateConstructor()

        var submodules = mutableMapOf<String, JavaSdkSubmodule>()

        for (item in sdk.items) {
            var (submoduleName, trimmedMethodName) = JavaSdkItem.generateMethodName(item, sdk)

            var submodule = submodules.getOrPut(submoduleName) {
                JavaSdkSubmodule(submoduleName)
            }
            submodule.items.add(JavaSdkItem(item, module = this, methodName = trimmedMethodName))
        }

        for (submodule in submodules.values) {
            submodule.generate(bindingsClass)
        }

        for (enum in sdk.enums) {
            JavaSdkEnum(enum, module = this)
                .generate(sourceRoot)
        }

        return cu
    }

    fun javaTypeFor(type: SdkItem.Type?, useRawTypes: Boolean = false, annotations: Boolean = false): Type {
        return when (type) {
            null -> VoidType()
            is SdkItem.Type.Bool -> PrimitiveType(Primitive.BOOLEAN)
            is SdkItem.Type.Int -> PrimitiveType(Primitive.INT)
            is SdkItem.Type.Long -> PrimitiveType(Primitive.LONG)
            is SdkItem.Type.Float -> PrimitiveType(Primitive.FLOAT)
            is SdkItem.Type.Double -> PrimitiveType(Primitive.DOUBLE)
            is SdkItem.Type.StringPtr -> StaticJavaParser.parseClassOrInterfaceType("String")
                .apply {
                    if (annotations) {
                        addMarkerAnnotation("org.jetbrains.annotations.NotNull")
                    }
                }
            is SdkItem.Type.Named -> {
                if (useRawTypes) {
                    var underlyingType = enums[type.name]?.underlyingType
                    if (underlyingType != null) return javaTypeFor(underlyingType)
                }

                ClassOrInterfaceType(null, JavaSdkEnum.generateEnumName(type.name))
                    .apply {
                        if (annotations) {
                            addMarkerAnnotation("org.jetbrains.annotations.NotNull")
                        }
                    }
            }
        }
    }

    fun hasRawType(type: SdkItem.Type): Boolean {
        return when (type) {
            is SdkItem.Type.Named -> enums[type.name]?.underlyingType != null
            else -> false
        }
    }
}

class JavaSdkSubmodule(var submoduleName: String) {
    var items = mutableListOf<JavaSdkItem>()

    fun generate(parentClass: ClassOrInterfaceDeclaration) {
        var submoduleClass = ClassOrInterfaceDeclaration(
            modifierListOf(Keyword.PUBLIC, Keyword.STATIC, Keyword.FINAL),
            false,
            submoduleName
        )
            .addStaticInitAnnotation()
            .addPrivateConstructor()

        parentClass.addMember(submoduleClass)

        for (item in items) {
            item.generate(submoduleClass)
        }
    }
}

class JavaSdkItem(val sdk: SdkItem, val module: JavaSdkModule, val methodName: String = sdk.name) {
    fun generate(bindingsClass: ClassOrInterfaceDeclaration) {
        val rawMethod = bindingsClass
            .addMethod(sdk.name + "_raw", Keyword.PRIVATE, Keyword.STATIC, Keyword.NATIVE)
            .setType(module.javaTypeFor(sdk.returns, useRawTypes = true, annotations = true))
            .removeBody()

        rawMethod.addAndGetAnnotation("org.teavm.interop.Import")
            .addPair("module", StringLiteralExpr(module.sdk.name))
            .addPair("name", StringLiteralExpr(sdk.name))

        generateParams(sdk.params, rawMethod, true)

        var method = bindingsClass
            .addMethod(methodName, Keyword.PUBLIC, Keyword.STATIC)
            .setType(module.javaTypeFor(sdk.returns, annotations = true))
            .setJavadocComment(sdk.name)

        generateParams(sdk.params, method)
        generateBody(method, rawMethod)
    }

    private fun generateParams(
        params: Iterable<SdkItem.Param>,
        method: MethodDeclaration,
        useUnderlyingTypes: Boolean = false
    ) {
        for (param in params) {
            var paramType = module.javaTypeFor(param.type, useUnderlyingTypes)
            method.addAndGetParameter(paramType, param.name)
        }
    }

    private fun generateBody(method: MethodDeclaration, rawMethod: MethodDeclaration) {
        var body = method.createBody()

        val nativeMethodCall = MethodCallExpr(null, rawMethod.name)
        for (param in sdk.params) {
            var arg: Expression = NameExpr(param.name)

            if (module.hasRawType(param.type)) {
                arg = MethodCallExpr(arg, "getRawValue")
            }

            nativeMethodCall.addArgument(arg)
        }

        var expr: Expression = nativeMethodCall

        if (sdk.returns != null && module.hasRawType(sdk.returns)) {
            var wrapper = module.javaTypeFor(sdk.returns) as ClassOrInterfaceType
            expr = ObjectCreationExpr(null, wrapper, nodeListOf(nativeMethodCall))
        }

        body.addStatement(
            if (method.type.isVoidType) {
                ExpressionStmt(expr)
            } else {
                ReturnStmt(expr)
            }
        )
    }

    companion object {
        private var actionVerbs =
            setOf("get", "set", "request", "update", "reset", "fill", "draw", "clear", "disable", "enable")

        fun generateMethodName(item: SdkItem, module: SdkModule): Pair<String, String> {
            var nameComponents = ArrayDeque(
                CaseFormat.LOWER_CAMEL
                    .to(CaseFormat.LOWER_UNDERSCORE, item.name)
                    .removePrefix(module.name + "_")
                    .split('_')
            )

            var moduleName = nameComponents.removeFirst()

            // Move verbs to front of method name
            var lastComponent = nameComponents.lastOrNull()
            if (actionVerbs.contains(lastComponent)) {
                nameComponents.add(0, nameComponents.removeLast())
            }

            var submoduleName = CaseFormat.LOWER_UNDERSCORE
                .to(CaseFormat.UPPER_CAMEL, moduleName)
            var trimmedMethodName = CaseFormat.LOWER_UNDERSCORE
                .to(CaseFormat.LOWER_CAMEL, nameComponents.joinToString("_"))

            return Pair(submoduleName, trimmedMethodName)
        }
    }
}

class JavaSdkEnum(val sdk: SdkEnum, val module: JavaSdkModule) {
    fun generate(sourceRoot: SourceRoot) {
        val name = generateEnumName(sdk.name)

        val cu = makeCompilationUnit(name, sourceRoot)
            .addHydrozoaGeneratedComment()

        val underlyingType = module.javaTypeFor(sdk.underlyingType)
        val record = RecordDeclaration(
            modifierListOf(Keyword.PUBLIC),
            name,
        )
            .apply { cu.addType(this) }
            .addHydrozoaGeneratedAnnotation()
            .setJavadocComment(sdk.name)
            .addParameter(underlyingType, "value")

        val recordType = ClassOrInterfaceType(null, record.name, null)

        for ((variantName, variantValue) in sdk.variants) {
            val literal: Expression = if (variantValue % 1.0 == 0.0) {
                IntegerLiteralExpr(variantValue.toInt().toString())
            } else {
                DoubleLiteralExpr(variantValue)
            }

            record
                .addFieldWithInitializer(
                    recordType,
                    generateMemberName(variantName, name),
                    ObjectCreationExpr(null, recordType, nodeListOf(
                        CastExpr(underlyingType, literal)
                    )),
                    Keyword.PUBLIC,
                    Keyword.STATIC,
                    Keyword.FINAL,
                )
                .setJavadocComment(variantName)
        }

        record.addMethod("getRawValue", Keyword.PUBLIC)
            .setType(underlyingType)
            .setBody(
                BlockStmt(
                    nodeListOf(ReturnStmt(NameExpr("value")))
                )
            )
    }

    companion object {
        fun generateEnumName(name: String): String =
            name
                .removePrefix("V5_")
                .removePrefix("V5")

        fun generateMemberName(name: String, enumName: String): String {
            val components = ArrayDeque(CaseFormat.LOWER_CAMEL
                .to(CaseFormat.LOWER_UNDERSCORE, name)
                .split('_'))
            val enumComponents = ArrayDeque(CaseFormat.LOWER_CAMEL
                .to(CaseFormat.LOWER_UNDERSCORE, enumName)
                .split('_'))

            for (redundantComponent in arrayOf("k", "v5")) {
                if (components.firstOrNull() == redundantComponent) {
                    components.removeFirst()
                } else {
                    break
                }
            }

            for (typeNameComponent in enumComponents) {
                if (components.firstOrNull() == typeNameComponent) {
                    components.removeFirst()
                } else {
                    break
                }
            }

            return CaseFormat.LOWER_UNDERSCORE
                .to(CaseFormat.UPPER_CAMEL, components.joinToString("_"))
        }
    }
}
